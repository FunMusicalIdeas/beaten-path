<div class="row">
    <div class="middle">
        <p>
            <i>
                Given a number, repeatedly metrically modulate by either the <a
                    href="https://en.wikipedia.org/wiki/Superparticular_ratio" target="_blank">superparticular ratio</a>
                or the subparticular ratio which has it as its numerator, at each point choosing — of these two ratios —
                the one which strays least from the original duration, and finally wrapping the piece when you've
                reached a meter very close to the original.
            </i>
        </p>
    </div>

    <div class="right"></div>
</div>

<div class="row">
    <div class="middle">
        <h3>
            Core Cycles
        </h3>
    </div>

    <div class="right"></div>
</div>

<div class="row">
    <div class="middle">
        <p>
            The first major step in materializing a Beaten Path is computing the <b>core cycle</b>.
            To do so, we need only a single parameter, what we call the <b>core</b>.
            The cycle is a series of values, starting with <b>1</b> and ending by wrapping back around to that same
            <b>1</b> (hence it being a cycle), where each next value in the cycle is found by multiplying the previous
            value by one of two important fractions which each <b>core</b> is associated with: a superparticular
            fraction, and a subparticular fraction. The superparticular is the fraction <b>core / (core - 1)</b>. The
            subparticular is the fraction <b>core / (core + 1)</b>. The cycle ends when you have arrived at a value that
            is extremely close to <b>1</b> again.
        </p>
    </div>

    <div class="right">
        <p>
            e.g., for core = 5, multiplying each step by either 5/6 or 5/4:
            <br>
            1 / 1
            <br>
            5 / 6
            <br>
            25 / 24
            <br>
            125 / 144
            <br>
            625 / 576
            <br>
            ...
            <br>
            95367431640625 / 95105071448064 ≈ 1
        </p>
    </div>
</div>

<div class="row">
    <div class="middle">
        <h3>
            Commas
        </h3>
        <p>
            You can never <i>exactly</i> reach <b>1</b> again, for a simple reason:
            Because each new factor in the numerator is <i>always</i> the core, and each new factor in the denominator
            is <i>never</i> the core, you can never cancel anything out, so the factorization grows increasingly complex
            forever.
        </p>
        <p>
            In spite of this bottomless pit of complexity, though, moments of near-convergence exist.
            For example, when core is <b>4</b>, you will be repeatedly multiplying either <b>4/3</b> or <b>4/5</b>.
            The first several values are:
        </p>
        <p>
            <b>
                1 / 1
                <br>
                4 / 5
                <br>
                16 / 15
                <br>
                64 / 75
                <br>
                256 / 225
                <br>
            </b>
        </p>
        <p>
            If you keep going, eventually we find a value very close to <b>1 / 1</b>:
        </p>
        <p>
            <b>4294967296 / 4271484375</b>
        </p>
        <p>
            In decimal expansion that's <b>≈1.0054976019899406</b>.
        </p>
        <p>
            And in terms of its factorization, that requires sixteen steps to complete, because it has thirty-two
            <b>2</b>'s in the numerator (two for each <b>4</b>, the <b>core</b>) and it has seven <b>3</b>'s and nine
            <b>5</b>'s in the denominator.
        </p>
        <p>
            Since that value is so close to <b>1</b>, we don't actually include it in the cycle.
            Instead, we just connect our cycle's end back up to it's beginning at this point.
            No one should notice that we moved to <b>1</b> instead of to <b>4294967296 / 4271484375</b>.
        </p>
        <p>
            Such tiny ratios are known in the biz as <a href="https://en.xen.wiki/w/Comma" target="_blank">commas</a>.
            The comma for core 4 is known as the <a href="https://en.xen.wiki/w/Escapade_comma" target="_blank">escapade
            comma</a>.
        </p>
        <p>
            There are simpler commas which use only <b>4</b>'s on one side and only <b>3</b>'s and <b>5</b>'s on the
            other. For example, the "misty comma" has thirteen <b>2</b>'s in the numerator, and twelve <b>3</b>'s and
            three <b>5</b>'s
            in the denominator. At <b>67108864 / 66430125 ≈ 1.01021733739</b> it's not quite as close to 1, but there's
            a more important
            reason it is not the comma for core 4: You could not arrive at by following the Beaten Path process.
            The fact that there are thirteen <b>4</b>'s in the numerator suggests that the cycle completes in thirteen
            steps. However, that means there must be a total of thirteen <b>3</b>'s and <b>5</b>'s on the other side,
            one for
            each fraction we multiplied with a <b>4</b> in the numerator. As we can see, though, there are twelve plus
            three equals fifteen factors in the denominator.
        </p>
        <p>
            In other words, Beaten Path is less about the commas it happens to arrive at, and more about the path
            through them.
        </p>
        <h3>
            Absolute Ratio
        </h3>
        <p>
            But how do we pick which of the two - super- or sub-particular - we move by each step? Good question.
            Really, kind of "the" question of Beaten Path. The defining constraint of the Beaten Path process is that
            each next fraction is the one which, when you multiply it with the current value, gets you the closest to 1.
        </p>
        <p>
            We decide this by comparing the "absolute ratios" of the two possibilities.
            If an absolute value is for ensuring all values are on the same side of the additive identity, 0,
            then an absolute ratio is for ensuring all values are on the same side of the multiplicative identity, 1.
            In other words, if your value is greater than 1, take its reciprocal.
            That way we can compare the two possibilities, even if one is above <b>1</b> and one is below.
        </p>
        <p>
            For example, consider this step from <b>core</b> of <b>3</b>, ten steps in, where our value is <b>59049 /
            65536</b>.
            As usual, we have the choice of moving by either <b>3 / 4</b> or <b>3 / 2</b>.
            If we moved by <b>3 / 4</b> we would get <b>177147 / 262144</b>.
            If we moved by <b>3 / 2</b> we would get <b>177147 / 131072</b>.
            So which is closer to <b>1</b>, then: <b>177147 / 262144</b>, or <b>177147 / 131072</b>?
        </p>
        <p>
            Allow me to interrupt myself by first illustrating an important approach <i>not</i> to take (based on
            experience).
            Consider the two values' decimal expansions, <b>0.67576217651</b> and <b>1.35152435303</b>, respectively.
            We may be tempted to say that the former of the two is closer to <b>1</b>;
            the traditional absolute value of the difference between <b>1</b> and <b>0.67576217651</b> is only <b>0.32423782349</b>
            while the traditional absolute value of the difference between <b>1</b> and <b>1.35152435303</b> is a bit
            bigger at <b>0.35152435303</b>.
            However, comparing these two values arithmetically is unfair to the greater of the two.
            The lesser will only ever shrink in a range from 1 to approaching 0, while the greater can grow ad
            infinitum.
            We need an operation that equalizes the scale of both sides of the multiplicative identity.
            Enter absolute ratio.
        </p>
        <p>
            If we take the reciprocal of <b>177147 / 131072</b> so that it is also less than <b>1</b>, then we can
            compare it with <b>177147 / 262144</b>.
            So, finally, which is closer to <b>1</b>: <b>177147 / 262144</b>, or <b>131072 / 177147</b>?
            <b>131072 / 177147 ≈ 0.7399052764</b>. Recall that <b>177147 / 262144</b> was <b>0.67576217651</b>.
            So the answer which is closest to 1, as it turns out, is <b>131072 / 177147</b>!
            Perhaps surprisingly, the value with the greater absolute value difference is actually the value which is
            closer to <b>1</b> in the multiplicative sense.
        </p>
        <h3>
            Features
        </h3>
        <p>
            All this still is not enough information to create music.
            Well, it's easy enough to express this process musically.
            Assign note durations to the values of the core cycle.
            That way, as the piece moves from value to value, metric modulation occurs repeatedly, until finally upon
            wrapping around,
            we return to a beat value able to be conflated with the initial.
        </p>
        <p>
            Finally, to bring the music to life, assign the pitch as the reciprocal of the duration.
            As the duration goes down, the frequency goes up proportionally. In other words, every note will have the
            same number of vibrations.
        </p>
        <h3>
            Entities
        </h3>
        <p>
            Beaten Path may be articulated by a single entity. In this case the entity simply sounds each value of the
            cycle, and repeats.
        </p>
        <p>
            However, things get a bit more interesting when you start adding more entities.
        </p>
        <p>
            The rule here is that at no point is any entity playing the same note as any other entity.
            However, they are all playing sequential notes from the core cycle.
            With two entities, they'd begin the piece with one playing the first first value, the other playing the
            second.
            With three entities, they'd begin the piece by playing values 1, 2, and 3, respectively.
        </p>
        <p>
            Each note has a different pitch, so they form a chord together.
            But the fact that they each have a different duration poses a problem: how to keep the entities together?
            Assuming we want to keep them together, somewhat like typical music with chord progressions and a chord per
            measure and such.
            Well, the answer to this is: take the lowest common multiple of all of the entities' values, and use that as
            your bar length.
            Each entity repeats its note however many times it takes to fill that duration, but when that duration comes
            and every entity
            is in sync, that's our opportunity to make a change as we go to a new bar.
        </p>
        <p>
            Only one entity changes at a time. The entities leapfrog through the values of the core cycle.
            That is, when it is an entity's turn to advance through the core cycle, it jumps to the first value which is
            not currently reached
            by any other entity yet.
            In this way, the chord that the entities make together changes only one of its pitches each new bar.
            And each entity stays on each note it plays a number of bars equal to the entity count before changing to
            the next note.
        </p>
        <h3>
            Loop
        </h3>
        <p>
            When the count of entities does not divide evenly into the core cycle length, we find ourselves in a
            situation where
            we have completed a core cycle — what we call a <b>loop</b> — but the entities won't line up with each
            other.
            In other words, the entity whose turn it is to jump will not be wanting to jump to the note it played in the
            first bar.
            Instead it will be wanting to jump to the first note some other entity played.
        </p>
        <p>
            No problem though. It just means that the pattern in its entirety will be extended long enough that it fits
            the lowest common multiple
            of the entity count and the core cycle length. It'll keep repeating the core cycle, each time the entities
            trading places,
            until finally the entities have traded all the way back to their original positions.
        </p>
    </div>

    <div class="right"></div>
</div>
